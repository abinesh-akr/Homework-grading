<!DOCTYPE html>
<html lang="en">

<head>
    <title>Optimized Automated Essay Grader</title>
    <meta charset="utf-8" />
    <link type="text/css" rel="stylesheet" href="../style.css" />
</head>

<body>
    <div id="canvas">
        <div>
            <div id="heading"> <h1><center> OPTIMIZED AUTOMATED ESSAY GRADER </center></h1></div>
            <br /><br /> <hr /> <hr /> <br />

        <div style="float:left; font-size:18pt" id="scoretable">
            <img src="../images/grade.jpg" />
            <h2> Overall Score</h2>
            <table border="1" align="right">
                <tr> <th class="big">GRADE (0-5)</th> <th class="big">2.35</th></tr>
                <tr> <th>Spelling(0-5)</th> <td>4.37</td></tr>
                <tr> <th>Grammar(0-5)</th> <td>1.93</td></tr>
                <tr> <th>Coherence(0-5)</th> <td>0.74</td></tr>
            </table>
        </div>

        <div style="float:right" id="statistics">
            <img src="../images/stats.jpg" />
            <h2> Essay Statistics</h2>
            <table border="1" align="left">
                <tr align='left'> <th>Word Count</th> <td>994</td></tr>
                <tr align='left'> <th>Sentence Count</th> <td>3</td></tr>
                <tr align='left'> <th>Paragraph Count</th> <td>256</td></tr>
                <tr align='left'> <th>Average Sentence Length</th> <td>331.33</td> </tr>
                <tr align='left'> <th>Standard Deviation from the Average Sentence Length</th> <td>275.71</td> </tr>
            </table>
        </div>
        </div>

        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /> <hr /> <hr /> <br />

        <div id="spellings">
            <img src="../images/spell.jpg" />
            <h2> Spellings </h2>
            <h3 style="text-align:left">Number of Misspelt Words ::125</h3>
            <h2 style="text-align:right" class="score" >Score :: 4.37</h2>

            <table border="1">
                <thead> <tr> <th>Misspelt Word</th> <th> Spelling Suggestions</th> </tr> </thead>
                <tbody><tr> <td>22bcs030</td> <td> []</td> </tr><tr> <td>mepcolinux</td> <td> ['limicoline']</td> </tr><tr> <td>struct</td> <td> ['strict', 'strut', 'struck', 'structure', 'destruct', 'instruct', 'obstruct']</td> </tr><tr> <td>sqimp</td> <td> ['simp', 'skimp', 'sq imp', 'sq-imp']</td> </tr><tr> <td>isempty</td> <td> ['is empty', 'is-empty', 'empty']</td> </tr><tr> <td>ptr</td> <td> ['pt', 'pr', 'tr', 'rpt', 'per', 'pts', 'str', 'par', 'ctr', 'ptg', 'ppr', 'phr', 'p tr', 'pt r']</td> </tr><tr> <td>malloc</td> <td> ['mallow', 'Mallorca']</td> </tr><tr> <td>sizeof</td> <td> ['size of', 'size-of', 'size']</td> </tr><tr> <td>printf</td> <td> ['print', 'prints', 'print f']</td> </tr><tr> <td>ShortestAugmentingPath</td> <td> ['Statementing']</td> </tr><tr> <td>Poped</td> <td> ['Pope', 'Oped', 'Roped', 'Toped', 'Loped', 'Coped', 'Doped', 'Moped', 'Hoped', 'P oped', 'Po ped', 'Po-ped', 'Pope d', 'Piped', 'Pooed']</td> </tr><tr> <td>labled</td> <td> ['balled', 'labeled', 'tabled', 'cabled', 'ladled', 'gabled', 'fabled', 'la bled', 'la-bled', 'lab led', 'lab-led', 'laudable', 'blabbed', 'lablab', 'bedabble']</td> </tr><tr> <td>nFLow</td> <td> ['n Flow', 'flow', 'inflow', 'flown']</td> </tr><tr> <td>nResidue</td> <td> ['n Residue', 'residue', 'nonresidual']</td> </tr><tr> <td>ipMat</td> <td> ['shipmate']</td> </tr><tr> <td>ajMat</td> <td> ['Amati']</td> </tr><tr> <td>nEnter</td> <td> ['n Enter', 'tenner', 'enter', 'neater', 'renter', 'netter', 'tenter', 'center', 'neuter', 'venter', 'centner', 'terrene', 'interne', 'terpene']</td> </tr><tr> <td>scanf</td> <td> ['scan', 'scans', 'scarf', 'scant', 'scan f', 'Scan']</td> </tr><tr> <td>nFor</td> <td> ['n For', 'nor', 'for']</td> </tr><tr> <td>nSource</td> <td> ['n Source', 'source']</td> </tr><tr> <td>nDestination</td> <td> ['n Destination', 'destination', 'desalination', 'designation', 'underestimation', 'detestation']</td> </tr><tr> <td>nCost</td> <td> ['n Cost', 'cost', 'Costco']</td> </tr><tr> <td>goto</td> <td> ['got', 'goo', 'goth', 'gobo', 'koto', 'Soto', 'Toto', 'go to', 'go-to', 'got o', 'Togo']</td> </tr><tr> <td>nStart</td> <td> ['n Start', 'start', 'instar', 'tartan']</td> </tr><tr> <td>th</td> <td> ['ht', 'Th', 't', 'h', 'the', 'nth', 'tho', 'thy', 'fth', 'Eth', 'eh', 'ts', 'sh', 'ti', 'ta']</td> </tr><tr> <td>nSink</td> <td> ['n Sink', 'sink']</td> </tr><tr> <td>func</td> <td> ['fun', 'fund', 'funk', 'fun c', 'Funchal']</td> </tr><tr> <td>nFinal</td> <td> ['n Final', 'final', 'finial', 'infernal']</td> </tr><tr> <td>nMAXIMUM</td> <td> ['n Maximum', 'maximum', 'maximin']</td> </tr><tr> <td>makefile</td> <td> ['make file', 'make-file', 'filmmaker']</td> </tr><tr> <td>exe</td> <td> ['exr', 'ex', 'exes', 'exec', 'ere', 'ext', 'exc', 'exp', 'eye', 'eve', 'eke', 'ewe', 'ex e', 'Ex']</td> </tr><tr> <td>lqueue</td> <td> ['queue', 'l queue', 'pulque']</td> </tr></tbody>
            </table>
        </div>
        <br /> <hr /> <hr /> <br />

        <div id="grammar">
            <img src="../images/grammar.jpg" />
            <h2> Grammar </h2>
            <h2 style="text-align:right" class="score" >Score :: 1.93</h2>

            <table border="0">
                <thead> <tr> <th>Sentences</th> <th> Score</th> </tr> </thead>
                <tbody><tr> <td>//</td> <td> 5</td> </tr><tr> <td>F[i][j]=0;
   R=(int **) malloc((n+1)*sizeof(int*));       //residue matrix
   for(i=0;i<n+1;i++)
      R[i]=(int *) malloc((n+1)*sizeof(int));
   for(i=0;i<n+1;i++)
      </td> <td> 5</td> </tr><tr> <td>for(j=0;j<n+1;j++)
         </td> <td> 5</td> </tr><tr> <td>for(i=0;i<n+1;i++)
      </td> <td> 5</td> </tr><tr> <td>F[i]=(int *) malloc((n+1)*sizeof(int));
   </td> <td> 5</td> </tr><tr> <td>F=(int **) malloc((n+1)*sizeof(int*));       //flow matrix
   for(i=0;i<n+1;i++)
      </td> <td> 5</td> </tr><tr> <td>int **G,**F,**R;
   G=(int **) malloc((n+1)*sizeof(int*));       //cost matrix
   for(i=0;i<n+1;i++)
      G[i]=(int *) malloc((n+1)*sizeof(int));
   </td> <td> 5</td> </tr><tr> <td>j=i;
            if(x[2*i]>0)
            </td> <td> 5</td> </tr><tr> <td>sink have been labeled (path from source to sink found)
      {
         j=sink;
         while(j!=1)
         {

            if(x[(2*j)]==i)
               F[i][j]=F[i][j]+x[(2*sink)-1];   //add max flow value of identified path to flow graph (forward edge)
            else
               F[j][i]=F[j][i]-x[(2*sink)-1];   //sub max flow value of identified path to flow graph(backward edge)
            </td> <td> 5</td> </tr><tr> <td>adjacent vertex with backward edge

               }
            }
      int y=30;
      if(x[(2*sink)]!=0)        //If</td> <td> 5</td> </tr><tr> <td>//check for label
            {
               if(F[j][i]>0)
               {
                  x[(2*j)-1]=F[j][i];
                  if(x[(2*i)-1]<x[(2*j)-1]</td> <td> 5</td> </tr><tr> <td>backward edges
         if(R[j][i]>0)
            if(x[(2*j)-1]==0)   </td> <td> 5</td> </tr><tr> <td>adjacent vertex with forward edge

               }
            }
      }
      for(j=2;j<n;j++)          //finding</td> <td> 5</td> </tr><tr> <td>Queue*));
   </td> <td> 5</td> </tr><tr> <td>[22bcs030@mepcolinux 2]$vi makefile
[22bcs030@mepcolinux 2]$cat makefile
exe : imp.o app.o sqimp.o
        cc imp.o sqimp.o app.o -o exe -lm
imp.o : imp.c head.h
        cc imp.c -c -lm -lqueue
sqimp.o : sqimp.c sq.h
        cc sqimp.c -c
app.o : app.c head.h
        cc app.c -c -lm
</td> <td> 4</td> </tr><tr> <td>i th vertex label   = x[(2*i)]
                                        </td> <td> 4</td> </tr><tr> <td>q->front=NULL;
   q->rear=NULL;
   push(q,source);              //push source into queue
   while(!isempty(q))
   {
      int i;
      i=pop(q);                 // pop front vertex
      printf("\n Poped vertex : %d\n",i);
      for(j=1;j<n+1;j++)        //finding</td> <td> 4</td> </tr><tr> <td>for(j=0;j<n+1;j++)
         R[i][j]=0;


   ipMat(G,R,n+1);                      //input residue matrix

   printf("\nStart vertex  : ");
   for(i=0;i<(2*(n+1));i++)
      a[i]=0;
   scanf("%d",&source);                 //</td> <td> 2</td> </tr><tr> <td>i=x[(2*i)];
            else
               i=(-1*x[2*i]);
         }
         erase(x,n);            //remove</td> <td> 2</td> </tr><tr> <td>)
                     x[(2*j)-1]=x[(2*i)-1];
                  x[(2*j)]= -1*i;
                  print(x,n);
                  push(q,j);    //push</td> <td> 2</td> </tr><tr> <td>forward edges
      {
         if(R[i][j]>0)
            if(x[(2*j)-1]==0)   //checking labled or not
            {
               R[i][j]=G[i][j]-F[i][j];
               if(R[i][j]>0)
               {
                  x[(2*j)-1]=R[i][j];
                  if(x[(2*i)-1]<x[(2*j)-1])
                     x[(2*j)-1]=x[(2*i)-1];
                  x[(2*j)]=i;
                  print(x,n);
                  push(q,j);    //push</td> <td> 2</td> </tr><tr> <td>[22bcs030@mepcolinux 2]$cat head.h
#include "stdio.h"
#include "math.h"

[22bcs030@mepcolinux 2]$cat sq.h
#include "head.h"
struct Node;
struct Node
{
   struct Node *next;
   int value;
};
struct Queue
{
   struct Node *front;
   struct Node *rear
};



</td> <td> 2</td> </tr><tr> <td>[22bcs030@mepcolinux 2]$cat app.c
#include "head.h"
int main()
{
   printf("\nEnter n : ");
   int j,i,n,d;
   scanf("%d",&n);
   int k,*a;
   int source,s=0;

   a=(int*)malloc((2*(n+1))*sizeof(int));
   </td> <td> -1</td> </tr><tr> <td>[22bcs030@mepcolinux 2]$cat imp.c
#include "head.h"
#include "sq.h"
#include <math.h>
void print(int *a,int n)
{
   int i,j;
   </td> <td> -1</td> </tr><tr> <td>[22bcs030@mepcolinux 2]$cat sqimp.c
#include "sq.h"
int isempty(struct Queue *q)
{
        if(q->front==NULL)
        {
           return 1;
        }
        else
        {
           return 0;
        }
}
int push(struct Queue *q,int v)
{
   struct Node *ptr;
   ptr = (struct Node * ) malloc(sizeof(struct Node));

       ptr -> value = v;
       if (q->front == NULL) {
          q->front = ptr;
          q->rear = ptr;
          q->front -> next = NULL;
          q->rear -> next = NULL;
         }
       else {
           q->rear -> next = ptr;
           q->rear = ptr;
          q->rear -> next = NULL;
        }

}
int pop(struct Queue *q)
{
        if(q->front==NULL)
        {
                return 0;
        }
        else
        {
                int i = q->front->value;
               /* struct Node *n;
                if(n!=q->front->next)
                   n=q->front->next;
                q->front=n;*/
                struct Node *ptr=q->front;
                q->front=q->front->next;
                free(ptr);
                return i;
        }
}
</td> <td> -6</td> </tr><tr> <td>i th vertex residue = x[(2*i)-1]


   a[1]=INFINITY;
   a[2]=0;

   printf("\nSink vertex   : ");
   scanf("%d",&d);

   ShortestAugmentingPath(source,d,G,F,R,a,n);  //func call


   printf("\nFinal Flow Graph :\n");
   display(F,n);
   printf("\nFinal Residue Graph :\n");
   display(R,n);

   for(i=1;i<n+1;i++)                           // computing max flow from resultant Flow graph
      s=s+F[1][i];                              // Inflow(sink) = Outflow(source)
   printf("\nMAXIMUM FLOW : %d\n\n",s);

}
</td> <td> -7</td> </tr><tr> <td>for(i=2;i<n+1;i++)
   {
      if(a[(2*i)-1]==0)
      {
         printf(" [%d] : x/x \n",i);
      }
      else
      printf(" [%d] : %d/%d \n",i,a[(2*i)-1],a[2*i]);
   }
   printf("\n");
}

void display(int **F,int n)
{
   int i,j;
   for(i=1;i<n+1;i++)
   {
     for(j=1;j<n+1;j++)
        printf(" %d ",F[i][j]);
     printf("\n");
   }

}

void erase(int *x,int n)
{
   int i;
   for(i=2;i<(n+1);i++)
   {
      x[(2*i)-1]=0;
      x[(2*i)]=0;
   }
}

void ShortestAugmentingPath(int source,int sink,int **G,int **F,int **R,int *x,int n)
{
   int j;
  printf("%d-- ",source);
   struct Queue *q;
   q=(struct Queue *) malloc(sizeof(struct</td> <td> -11</td> </tr><tr> <td>all label except for source
         q->front=NULL;
         q->rear=NULL;
         push(q,source);        // push source to queue
         printf("\nFLow Graph \n");
         display(F,n);
         printf("\nResidue Graph \n");
         display(R,n);
      }
   }
}


void ipMat(int **ajMat,int **R,int n)
{
   int cost,j,i,s,d;
   printf("\nEnter number of edges              : ");
   scanf("%d",&i);

   for(j=0;j<i;j++)
   {
r:
      printf("\nFor edge [ %d ]",j+1);
      printf("\nSource      : ");
      scanf("%d",&s);
      printf("\nDestination : ");
      scanf("%d",&d);
      printf("\nCost        : ");
      scanf("%d",&cost);
      if(s < n && d < n)
      {
         ajMat[s][d]=cost;
         R[s][d]=cost;
      }
      else
      {
         printf("\nEnter valid data !!");
         goto r;
      }
   }
}
</td> <td> -12</td> </tr> </tbody>
            </table>
        </div>
        <br /> <hr /> <hr /> <br />


        <div id="coherence">
            <img src="../images/coherence.jpg" />
            <h2> Coherence </h2>
            <h2 class="score" style="text-align:right"> Score :: 0.74</h2>

            <table border="0">
                <thead> <tr> <th>Sentences</th> <th> Score</th> </tr> </thead>
                <tbody></tbody>
            </table>
        </div>
        <br /> <hr /> <hr /> <br />


        <div>
        <img src="../images/essay.jpg" />

        <h2> Essay </h2> <div id="essay">[22bcs030@mepcolinux 2]$cat head.h#include "stdio.h"#include "math.h"<br /> <br />[22bcs030@mepcolinux 2]$cat sq.h#include "head.h"struct Node;struct Node{   struct Node *next;   int value;};struct Queue{   struct Node *front;   struct Node *rear};<br /> <br /><br /> <br /><br /> <br />[22bcs030@mepcolinux 2]$cat sqimp.c#include "sq.h"int isempty(struct Queue *q){        if(q->front==NULL)        {           return 1;        }        else        {           return 0;        }}int push(struct Queue *q,int v){   struct Node *ptr;   ptr = (struct Node * ) malloc(sizeof(struct Node));<br /> <br />       ptr -> value = v;       if (q->front == NULL) {          q->front = ptr;          q->rear = ptr;          q->front -> next = NULL;          q->rear -> next = NULL;         }       else {           q->rear -> next = ptr;           q->rear = ptr;          q->rear -> next = NULL;        }<br /> <br />}int pop(struct Queue *q){        if(q->front==NULL)        {                return 0;        }        else        {                int i = q->front->value;               /* struct Node *n;                if(n!=q->front->next)                   n=q->front->next;                q->front=n;*/                struct Node *ptr=q->front;                q->front=q->front->next;                free(ptr);                return i;        }}[22bcs030@mepcolinux 2]$cat imp.c#include "head.h"#include "sq.h"#include <math.h>void print(int *a,int n){   int i,j;   for(i=2;i<n+1;i++)   {      if(a[(2*i)-1]==0)      {         printf(" [%d] : x/x \n",i);      }      else      printf(" [%d] : %d/%d \n",i,a[(2*i)-1],a[2*i]);   }   printf("\n");}<br /> <br />void display(int **F,int n){   int i,j;   for(i=1;i<n+1;i++)   {     for(j=1;j<n+1;j++)        printf(" %d ",F[i][j]);     printf("\n");   }<br /> <br />}<br /> <br />void erase(int *x,int n){   int i;   for(i=2;i<(n+1);i++)   {      x[(2*i)-1]=0;      x[(2*i)]=0;   }}<br /> <br />void ShortestAugmentingPath(int source,int sink,int **G,int **F,int **R,int *x,int n){   int j;  printf("%d-- ",source);   struct Queue *q;   q=(struct Queue *) malloc(sizeof(struct Queue*));   q->front=NULL;   q->rear=NULL;   push(q,source);              //push source into queue   while(!isempty(q))   {      int i;      i=pop(q);                 // pop front vertex      printf("\n Poped vertex : %d\n",i);      for(j=1;j<n+1;j++)        //finding forward edges      {         if(R[i][j]>0)            if(x[(2*j)-1]==0)   //checking labled or not            {               R[i][j]=G[i][j]-F[i][j];               if(R[i][j]>0)               {                  x[(2*j)-1]=R[i][j];                  if(x[(2*i)-1]<x[(2*j)-1])                     x[(2*j)-1]=x[(2*i)-1];                  x[(2*j)]=i;                  print(x,n);                  push(q,j);    //push adjacent vertex with forward edge<br /> <br />               }            }      }      for(j=2;j<n;j++)          //finding backward edges         if(R[j][i]>0)            if(x[(2*j)-1]==0)   //check for label            {               if(F[j][i]>0)               {                  x[(2*j)-1]=F[j][i];                  if(x[(2*i)-1]<x[(2*j)-1])                     x[(2*j)-1]=x[(2*i)-1];                  x[(2*j)]= -1*i;                  print(x,n);                  push(q,j);    //push adjacent vertex with backward edge<br /> <br />               }            }      int y=30;      if(x[(2*sink)]!=0)        //If sink have been labeled (path from source to sink found)      {         j=sink;         while(j!=1)         {<br /> <br />            if(x[(2*j)]==i)               F[i][j]=F[i][j]+x[(2*sink)-1];   //add max flow value of identified path to flow graph (forward edge)            else               F[j][i]=F[j][i]-x[(2*sink)-1];   //sub max flow value of identified path to flow graph(backward edge)            j=i;            if(x[2*i]>0)            i=x[(2*i)];            else               i=(-1*x[2*i]);         }         erase(x,n);            //remove all label except for source         q->front=NULL;         q->rear=NULL;         push(q,source);        // push source to queue         printf("\nFLow Graph \n");         display(F,n);         printf("\nResidue Graph \n");         display(R,n);      }   }}<br /> <br /><br /> <br />void ipMat(int **ajMat,int **R,int n){   int cost,j,i,s,d;   printf("\nEnter number of edges              : ");   scanf("%d",&i);<br /> <br />   for(j=0;j<i;j++)   {r:      printf("\nFor edge [ %d ]",j+1);      printf("\nSource      : ");      scanf("%d",&s);      printf("\nDestination : ");      scanf("%d",&d);      printf("\nCost        : ");      scanf("%d",&cost);      if(s < n && d < n)      {         ajMat[s][d]=cost;         R[s][d]=cost;      }      else      {         printf("\nEnter valid data !!");         goto r;      }   }}[22bcs030@mepcolinux 2]$cat app.c#include "head.h"int main(){   printf("\nEnter n : ");   int j,i,n,d;   scanf("%d",&n);   int k,*a;   int source,s=0;<br /> <br />   a=(int*)malloc((2*(n+1))*sizeof(int));   int **G,**F,**R;   G=(int **) malloc((n+1)*sizeof(int*));       //cost matrix   for(i=0;i<n+1;i++)      G[i]=(int *) malloc((n+1)*sizeof(int));   F=(int **) malloc((n+1)*sizeof(int*));       //flow matrix   for(i=0;i<n+1;i++)      F[i]=(int *) malloc((n+1)*sizeof(int));   for(i=0;i<n+1;i++)      for(j=0;j<n+1;j++)         F[i][j]=0;   R=(int **) malloc((n+1)*sizeof(int*));       //residue matrix   for(i=0;i<n+1;i++)      R[i]=(int *) malloc((n+1)*sizeof(int));   for(i=0;i<n+1;i++)      for(j=0;j<n+1;j++)         R[i][j]=0;<br /> <br /><br /> <br />   ipMat(G,R,n+1);                      //input residue matrix<br /> <br />   printf("\nStart vertex  : ");   for(i=0;i<(2*(n+1));i++)      a[i]=0;   scanf("%d",&source);                 // i th vertex label   = x[(2*i)]                                        // i th vertex residue = x[(2*i)-1]<br /> <br /><br /> <br />   a[1]=INFINITY;   a[2]=0;<br /> <br />   printf("\nSink vertex   : ");   scanf("%d",&d);<br /> <br />   ShortestAugmentingPath(source,d,G,F,R,a,n);  //func call<br /> <br /><br /> <br />   printf("\nFinal Flow Graph :\n");   display(F,n);   printf("\nFinal Residue Graph :\n");   display(R,n);<br /> <br />   for(i=1;i<n+1;i++)                           // computing max flow from resultant Flow graph      s=s+F[1][i];                              // Inflow(sink) = Outflow(source)   printf("\nMAXIMUM FLOW : %d\n\n",s);<br /> <br />}[22bcs030@mepcolinux 2]$vi makefile[22bcs030@mepcolinux 2]$cat makefileexe : imp.o app.o sqimp.o        cc imp.o sqimp.o app.o -o exe -lmimp.o : imp.c head.h        cc imp.c -c -lm -lqueuesqimp.o : sqimp.c sq.h        cc sqimp.c -capp.o : app.c head.h        cc app.c -c -lm</div></div> <br /> <hr /> <hr /> <br />
        <div id="conclusion">
            Leleih K. Emmanuel<br /> Natural Language Processing enthusiast
        </div>

    </div>

</body>

</html>


